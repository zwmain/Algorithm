# 0096.不同的二叉搜索树

链接：[0096.不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

对于n个数，不论这些数是哪些，只要数量是n个，那么组成的二叉搜索树的情况就是一致的。

固定根节点取值，那么以固定值为根节点的情况，为左子树的所有情况乘以右子树所有情况。

对于本题，一个二叉搜索树，从1到n连续。假设以i为根节点，那么左子树就有i-1个元素，右子树就有n-i个节点

1. `dp[i]`的含义：由i个节点组成的二叉树的的情况
2. 以j为头节点，左边就有j-1个节点，右边有i-j个节点；那么以j为头节点时，就有`dp[j-1]*dp[i-j]`个情况；递推公式`dp[i]=sum(dp[j-1]*dp[i-j]),j=[1,i]`
3. 初始化：`dp[0]=1`，空树也是二叉搜索树；
4. 遍历顺序：从1开始遍历

```c++
class Solution {
public:
    int numTrees(int n)
    {
        // dp[i]的含义：由i个节点组成的二叉树的的情况
        // 以j为头节点，左边就有j-1个节点，右边有i-j个节点
        // 那么以j为头节点时，就有dp[j-1]*dp[i-j]个情况
        // dp[i]=sum(dp[j-1]*dp[i-j]),j=[1,i]
        // 初始化：dp[0]=1，空树也是二叉搜索树；
        // 遍历顺序：从1开始遍历，
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int i = 1; i <= n; ++i) {
            dp[i] = 0;
            for (int j = 1; j <= i; ++j) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};

```



